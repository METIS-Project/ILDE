/*******************************************************************************
 * Copyright (C) 2015 Intelligent & Cooperative Systems Research Group/Education,
 * Media, Computing & Culture (GSIC-EMIC). University of Valladolid(UVA). 
 * Valladolid, Spain. https://www.gsic.uva.es/
 * 
 * This file is part of Glue!PS.
 * 
 * Glue!PS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or 
 * (at your option) any later version.
 * 
 * Glue!PS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*
 * CopperCore, an IMS-LD level C engine
 * Copyright (C) 2003 Harrie Martens and Hubert Vogten
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program (/license.txt); if not,
 * write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 *     Contact information:
 *     Open University of the Netherlands
 *     Valkenburgerweg 177 Heerlen
 *     PO Box 2960 6401 DL Heerlen
 *     e-mail: hubert.vogten@ou.nl or
 *             harrie.martens@ou.nl
 *
 *
 * Open Universiteit Nederland, hereby disclaims all copyright interest
 * in the program CopperCore written by
 * Harrie Martens and Hubert Vogten
 *
 * prof.dr. Rob Koper,
 * director of learning technologies research and development
 *
 */

package org.coppercore.validator;

import org.coppercore.common.MessageList;
import org.coppercore.common.Parser;
import org.coppercore.exceptions.SemanticException;
import org.coppercore.exceptions.ValidationException;
import org.doomdark.uuid.UUIDGenerator;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * The class represents to root class for all ims learning design validation
 * classes.
 * 
 * @author Harrie Martens
 * @author Hubert Vogten
 * @version $Revision: 1.11 $, $Date: 2005/12/13 12:50:14 $
 */
public abstract class IMSObject {
	/** contains the dom node of this object. */
	protected Node node;

	/** the learning design manifest this instance belongs to. */
	protected IMSLDManifest manifest = null;

	/** The identifier of this object. */
	protected String key = null;

	/** true if the key of this object is autogenerated. */
	protected boolean isGeneratedKey;

	/** true if this object is valid according to ims learning design. */
	protected boolean isValid = true;

	/**
	 * Default constructor for the IMSObject. 
	 * 
	 */
	public IMSObject() {
		// default constructor
	}

	/**
	 * Initializes the this object and sets it node parameter to the specified
	 * value.
	 * 
	 * @param aNode
	 *            Node the xml node this object is instanciated from
	 */
	protected void initialize(Node aNode) {
		node = aNode;

		// initialize object with key.
		setKey("");
	}

	/**
	 * Initializes the this object and sets it parameters to the specified
	 * values.
	 * 
	 * @param aNode
	 *            Node the xml node this object is instanciated from
	 * @param aManifest
	 *            IMSLDManifest the ims learning design manifest this instance
	 *            is a part of
	 */
	protected void initialize(Node aNode, IMSLDManifest aManifest) {
		initialize(aNode);

		manifest = aManifest;
	}

	/**
	 * Sets the key to the attribute value of the specified attribute.
	 * 
	 * <p>
	 * The attribute is retrieved from the xml node this object is instanciated
	 * from. If the attribute does not exist, or if the attribute has no value a
	 * key is autogenerated.
	 * 
	 * @param attributeName
	 *            String the name of the attribute to retrieve the key from
	 * @see #getKey
	 */
	public void setKey(String attributeName) {

		key = getNamedAttribute(attributeName);
		isGeneratedKey = false;

		if (key == null) {
			isGeneratedKey = true;
			key = UUIDGenerator.getInstance().generateTimeBasedUUID().toString();
		}
	}

	/**
	 * Returns the key of this instance.
	 * 
	 * @return String the key of this object
	 * @see #setKey
	 */
	public String getKey() {
		return key;
	}

	/**
	 * Validates the ims object.
	 * 
	 * @throws SemanticException
	 *             when there is a validation error
	 */
	protected abstract void isValid() throws SemanticException;

	/**
	 * Returns the value of the attribute with the specified name from the xml
	 * node of this object.
	 * 
	 * <p>
	 * If the attribute cannot be found, or the attribute has no value, the
	 * method returns null.
	 * 
	 * @param name
	 *            String the name of the attribute to search for
	 * @return String the value of the attribute if found, otherwise null
	 */
	public String getNamedAttribute(String name) {
		return Parser.getNamedAttribute(node, name);
	}

	/**
	 * Returns the value of the specified attribute of xml node of this object.
	 * 
	 * <p>
	 * The name of the attribute is defined by the namespace uri and the local
	 * name of the attribute.
	 * 
	 * <p>
	 * If the attribute could not be found, or if the attribute has no value the
	 * method returns null.
	 * 
	 * @param name
	 *            String the local name of the attribute to look for
	 * @param NS
	 *            String the namespace uri of the attribute to look for
	 * @return String the value of the attribute or null if the attribute could
	 *         not be found or it has no value.
	 */
	public String getNamedAttribute(String name, String NS) {
		return Parser.getNamedAttribute(node, name, NS);
	}

	private String positionOfNode(Node currentNode, Node target, String aPosition) {

		String position = null;

		if (currentNode != target) {
			if (currentNode.hasChildNodes()) {
				NodeList childNodes = currentNode.getChildNodes();

				int childElementCount = 0;
				int maxItem = childNodes.getLength();

				for (int i = 0; i < maxItem; i++) {
					Node child = childNodes.item(i);
					if (child.getNodeType() == Node.ELEMENT_NODE) {
						childElementCount++;
						if (child.equals(target)) {
							position = aPosition + "." + childElementCount;
							break;
						}
						String result = positionOfNode(child, target, (aPosition + "." + childElementCount));
						if (result != null) {
							position = result;
						}
					}
				}
			} else {
				return null;
			}
		} else {
			position = aPosition;
		}

		return position;
	}

	/**
	 * Returns an {@link String}object representing the hierarchical position
	 * of {@link Node}related with the {@link IMSObject}object in the DOM
	 * tree.
	 * 
	 * 
	 * @return the String represenation of the hierarchical position of the node
	 */
	public String position() {
		Node documentNode = node.getOwnerDocument().getDocumentElement();

		String result = positionOfNode(documentNode, node, "1");

		return result;

	}

	private String getNodePath(Node aNode) {
		String result = "";
		if (aNode != null && aNode.getNodeType() == Node.ELEMENT_NODE) {
			result = getNodePath(aNode.getParentNode()) + "->" + aNode.getLocalName();
		}
		return result;
	}

	/**
	 * Returns a string representation of the position of the current node and
	 * all of its parents.
	 * 
	 * @return String the string representation of the current node and its
	 *         parents
	 */
	public String getNodePath() {
		String result = getNodePath(node);

		if (this.isGeneratedKey) {
			return result;
		}
		return result + "[" + key + "]";
	}

	/**
	 * Resolves the reference of this object.
	 * <p>
	 * Must be called after all IMSObjects have been constructed.
	 * 
	 * @throws ValidationException
	 *             when there is an error resolving the references. This
	 *             exception is only thrown from subclasses that actually
	 *             implement this method.
	 */
	public void resolveReferences() throws ValidationException {
		// do nothing
	}

	/**
	 * Returns a String representation of this object.
	 * <p>
	 * This includes the position of the current object including its parents.
	 * 
	 * @return String the representation of this object
	 */
	public String toString() {

		return (node.getNodeName() + (isGeneratedKey ? "" : (": " + key)) + " {" + position() + "}" + getNodePath());
	}

	/**
	 * Returns the MessageList containing all logged messages.
	 * 
	 * @return MessageList the list containing all logged messages
	 */
	protected MessageList getLogger() {
		return manifest.getMessageList();
	}
}
